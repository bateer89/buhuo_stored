BEGIN

DECLARE today date;
DECLARE beginOfthisSeason date;
DECLARE beginOfthisSeasonvachar VARCHAR(255);
DECLARE endOfthisSeason date;
DECLARE endOfthisSeasonvachar VARCHAR(255);
DECLARE springfestivalbegin date;
DECLARE springfestivalend date;
#开始结束日期年份
DECLARE yearOfthisSeasonbegin VARCHAR(255);
DECLARE yearOfthisSeasonend VARCHAR(255);
##CT类促销取正常售价时间
declare c_endday int;
declare t_endday int;
select value into c_endday from zn_param where id=13;
select value into t_endday from zn_param where id=14;

SET springfestivalbegin=(SELECT x.startdate FROM zn_calendar x WHERE x.holidayid+0=1+0 AND YEAR(x.sundate)=YEAR(NOW()) LIMIT 1);
SET springfestivalend=(SELECT x.enddate FROM zn_calendar x WHERE x.holidayid+0=1+0 AND YEAR(x.sundate)=YEAR(NOW()) LIMIT 1);

SET today=thisDay;
SET yearOfthisSeasonbegin=DATE_FORMAT(today,'%Y');
SET yearOfthisSeasonend=CAST(CAST(yearOfthisSeasonbegin AS SIGNED)+1 AS CHAR(255));
SET beginOfthisSeasonvachar=CASE WHEN 
				ISNULL((SELECT zn_season_goods.begindate FROM zn_season_goods WHERE zn_season_goods.begindate<=DATE_FORMAT(today,'%m-%d') AND 
				zn_season_goods.enddate>DATE_FORMAT(today,'%m-%d') LIMIT 1))=1
		THEN CONCAT(yearOfthisSeasonbegin,'-',(SELECT zn_season_goods.begindate FROM zn_season_goods ORDER BY zn_season_goods.begindate DESC LIMIT 1))
		ELSE CONCAT(yearOfthisSeasonbegin,'-',(SELECT zn_season_goods.begindate FROM zn_season_goods WHERE zn_season_goods.begindate<=DATE_FORMAT(today,'%m-%d') AND 
				zn_season_goods.enddate>DATE_FORMAT(today,'%m-%d') LIMIT 1))
		END;
SET endOfthisSeasonvachar=CASE WHEN 
				ISNULL((SELECT zn_season_goods.begindate FROM zn_season_goods WHERE zn_season_goods.begindate<=DATE_FORMAT(today,'%m-%d') AND 
				zn_season_goods.enddate>=DATE_FORMAT(today,'%m-%d') LIMIT 1))=1
		THEN CONCAT(yearOfthisSeasonend,'-',(SELECT zn_season_goods.begindate FROM zn_season_goods ORDER BY zn_season_goods.begindate ASC LIMIT 1))
		ELSE CONCAT(yearOfthisSeasonbegin,'-',(SELECT zn_season_goods.enddate FROM zn_season_goods WHERE zn_season_goods.begindate<=DATE_FORMAT(today,'%m-%d') AND 
				zn_season_goods.enddate>=DATE_FORMAT(today,'%m-%d') LIMIT 1))
		END;
SET beginOfthisSeason=str_to_date(beginOfthisSeasonvachar,'%Y-%m-%d');
SET endOfthisSeason=str_to_date(endOfthisSeasonvachar,'%Y-%m-%d');


# 补货日补货
drop table if exists tmp_daily_tmp;
CREATE TABLE IF NOT EXISTS `tmp_daily_tmp` (
   xlid varchar(64),
  `goodsid` varchar(32) CHARACTER SET utf8mb4 DEFAULT NULL COMMENT '商品编码',
  `shopid` varchar(8) CHARACTER SET utf8mb4 DEFAULT NULL COMMENT '门店编码',
  `normalprice` decimal(16,2) DEFAULT NULL COMMENT '定价',
  `classtype` varchar(1) CHARACTER SET utf8mb4 DEFAULT NULL COMMENT '补货类型',
  `minorder` decimal(16,2) DEFAULT NULL COMMENT '最小起订量',
  `minstock` decimal(16,2) DEFAULT NULL COMMENT '最小库存数量',
  `closeqty` decimal(16,3) DEFAULT NULL COMMENT '昨日日终库存数量',

  `holiday_begindate` datetime DEFAULT NULL COMMENT '节日开始日期',
  `holiday_enddate` datetime DEFAULT NULL COMMENT '节日结束日期',
  `holidaytype` varchar(1) DEFAULT NULL COMMENT '节日属性',
  `zs` decimal(16,2) DEFAULT NULL COMMENT '春节指数',
  `ho_rate` decimal(16,2) DEFAULT NULL COMMENT '节日安全系数',

  `seasontype` varchar(1) DEFAULT NULL COMMENT '季节属性',
  `rate1` decimal(16,2) DEFAULT NULL COMMENT '季节时间达到Period1，日均销量的折扣比例',
  `rate2` decimal(16,2) DEFAULT NULL COMMENT '季节时间达到Period2，日均销量的折扣比例',
  `period1` decimal(16,2) DEFAULT NULL COMMENT '季节时间达到的比例1',
  `period2` decimal(16,2) DEFAULT NULL COMMENT '季节时间达到的比例2',

  `weekflag` char(1) CHARACTER SET utf8 DEFAULT NULL,
	`startweek`  int(1) NULL DEFAULT 0, 
  `orderdate` char(8) CHARACTER SET utf8 DEFAULT NULL,
  `safedays` int(11) DEFAULT NULL,
  `arrivaldays` int(11) DEFAULT NULL,
  `sdate` datetime DEFAULT NULL COMMENT '更新日期时间',
  `theoritical_qty` decimal(16,2) DEFAULT NULL,
  `actual_qty` decimal(16,2) DEFAULT NULL,
  `price` decimal(16,2) DEFAULT NULL,
  `planqty` decimal(16,3) DEFAULT NULL,
  `flag` char(1) DEFAULT '0',
  `manual_flag` char(1) DEFAULT '0',
  `dms` decimal(16,3) DEFAULT NULL COMMENT '实际售价对应的日均销量',
  `leftsalingDays` int(11) DEFAULT NULL COMMENT '当前剩余可销天数',
  `need_replenishment` int(11) DEFAULT NULL COMMENT '需要补货',
  `weekflag_days` int(11) DEFAULT 0 COMMENT 'buhuozhouqi',
	`trueprice` decimal(16,2) DEFAULT NULL COMMENT '实际售价',
  UNIQUE KEY `index_1` (`goodsid`,`shopid`) USING BTREE,
  KEY `index_2` (`goodsid`) USING BTREE,
  KEY `index_3` (`shopid`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

TRUNCATE TABLE tmp_daily_tmp;

IF NOT (DATE_SUB(springfestivalbegin,INTERVAL 6 DAY)<=today AND springfestivalend>=today) THEN

#j. 判断商品是否为订货日，如果是并且zn_goods表中商品flag=0（这一判断确保每个商品一天只进行一次补货）则触发这些商品补货 。
INSERT INTO tmp_daily_tmp (xlid,goodsid,shopid,normalprice,classtype,minorder,minstock,closeqty,holiday_begindate,holiday_enddate,
holidaytype,zs,ho_rate,seasontype,rate1,rate2,period1,period2,startweek,orderdate,weekflag,safedays,arrivaldays,sdate,weekflag_days)
SELECT 
zn_goods.xlid as xlid,
zn_goods.goodsid AS goodsid,
zn_goods.shopid AS shopid,
zn_goods.normalprice AS normalprice,
zn_goods.classtype AS classtype,
zn_goods.minorder AS minorder,
zn_goods.minstock AS minstock,
zn_goods.closeqty AS closeqty,
zn_goods.holiday_begindate AS holiday_begindate,
zn_goods.holiday_enddate AS holiday_enddate,
zn_goods.holidaytype AS holidaytype,
zn_goods.zs AS zs,
zn_goods.ho_rate AS ho_rate,

zn_goods.seasontype AS seasontype,
zn_goods.rate1 AS rate1,
zn_goods.rate2 AS rate2,
zn_goods.period1 AS period1,
zn_goods.period2 AS period2,
zn_config.Startweek AS startweek,
zn_config.orderdate AS orderdate,
zn_config.weekflag AS weekflag,#补货周期
zn_config.safedays AS safedays,#安全库存天数
zn_config.arrivaldays AS arrivaldays,#到货周期
zn_goods.sdate AS sdate,
DATEDIFF(get_next_buhuo_date(weekflag,zn_config.Orderdate,zn_config.Startweek,today),today) AS weekflag_days 
FROM zn_goods,zn_config 
WHERE zn_goods.shopid=shopId AND zn_goods.flag=0 AND zn_config.shopid=shopId AND 
zn_goods.classtype=zn_config.Classtype AND 
SUBSTR(zn_config.Orderdate,(dayofweek(thisday)+5)mod 7+1,1)='1' AND 
IF(zn_config.Weekflag=2,zn_config.Startweek mod 2=WEEKOFYEAR(today)mod 2,1);

ELSE CALL everyday_procedure_springfestival(shopId, thisDay);
end IF ;

#春节
#F4:B、C类商品退出A类商品的规则补货：春节结束后第一个补货日仍然按照A类的补货日进行补货，但是补货周期转成B或C类。
IF (springfestivalend<today AND today<DATE_ADD(springfestivalend,INTERVAL 15 DAY)) THEN 
TRUNCATE tmp_daily_tmp;
INSERT INTO tmp_daily_tmp (xlid,goodsid,shopid,normalprice,classtype,minorder,minstock,closeqty,holiday_begindate,holiday_enddate,
holidaytype,zs,ho_rate,seasontype,rate1,rate2,period1,period2,orderdate,weekflag,safedays,arrivaldays,sdate,weekflag_days) 
SELECT 
a.xlid as xlid,
a.goodsid AS goodsid,
a.shopid AS shopid,
a.normalprice AS normalprice,
a.classtype AS classtype,
a.minorder AS minorder,
a.minstock AS minstock,
a.closeqty AS closeqty,
a.holiday_begindate AS holiday_begindate,
a.holiday_enddate AS holiday_enddate,
a.holidaytype AS holidaytype,
a.zs AS zs,
a.ho_rate AS ho_rate,
a.seasontype AS seasontype,
a.rate1 AS rate1,
a.rate2 AS rate2,
a.period1 AS period1,
a.period2 AS period2,
c.orderdate AS orderdate,
b.weekflag AS weekflag,#补货周期
b.safedays AS safedays,#安全库存天数
b.arrivaldays AS arrivaldays,#到货周期
a.sdate AS sdate,
CASE WHEN (c.Weekflag=1 AND c.Classtype='A') THEN get_next_buhuo_days(c.Orderdate,today) 
							WHEN (c.Weekflag=1 AND c.Classtype='B') THEN 7
							WHEN c.Weekflag=2 THEN 14 ELSE 0 END AS weekflag_days
FROM zn_goods a,zn_config b,zn_config c
WHERE a.shopid=shopId AND b.shopid=shopId AND c.shopid=shopId AND a.flag=0 
AND b.Classtype=a.classtype AND c.classtype='A' AND a.holidaytype=2 AND
SUBSTR(c.Orderdate,(dayofweek(thisday)+5)mod 7+1,1)='1' AND
	IF(b.Weekflag=2,b.Startweek mod 2=WEEKOFYEAR(today)mod 2,1) AND
get_next_buhuo_date(b.Weekflag,c.Orderdate,b.Startweek,DATE_ADD(holiday_enddate,INTERVAL 1 DAY))=thisday
ON DUPLICATE KEY UPDATE
tmp_daily_tmp.xlid=VALUES(xlid),
tmp_daily_tmp.goodsid=VALUES(goodsid),
tmp_daily_tmp.shopid=VALUES(shopid),
tmp_daily_tmp.normalprice=VALUES(normalprice),
tmp_daily_tmp.classtype=VALUES(classtype),
tmp_daily_tmp.minorder=VALUES(minorder),
tmp_daily_tmp.minstock=VALUES(minstock),
tmp_daily_tmp.closeqty=VALUES(closeqty),
tmp_daily_tmp.holiday_begindate=VALUES(holiday_begindate),
tmp_daily_tmp.holiday_enddate=VALUES(holiday_enddate),
tmp_daily_tmp.holidaytype=VALUES(holidaytype),
tmp_daily_tmp.zs=VALUES(zs),
tmp_daily_tmp.ho_rate=VALUES(ho_rate),
tmp_daily_tmp.seasontype=VALUES(seasontype),
tmp_daily_tmp.rate1=VALUES(rate1),
tmp_daily_tmp.rate2=VALUES(rate2),
tmp_daily_tmp.period1=VALUES(period1),
tmp_daily_tmp.period2=VALUES(period2),
tmp_daily_tmp.orderdate=VALUES(orderdate),
tmp_daily_tmp.weekflag=VALUES(weekflag),
tmp_daily_tmp.safedays=VALUES(safedays),
tmp_daily_tmp.arrivaldays=VALUES(arrivaldays),
tmp_daily_tmp.sdate=VALUES(sdate),
tmp_daily_tmp.weekflag_days=VALUES(weekflag_days);
END IF;


/*节日越期*/
DELETE FROM zn_holiday_across WHERE zn_holiday_across.shopid=shopId AND 
DATE(zn_holiday_across.nextdate)<thisday;

DELETE d FROM tmp_daily_tmp d, zn_holiday_across a 
WHERE d.shopid=shopId AND a.shopid=shopId AND d.goodsid=a.goodsid AND DATE(a.nextdate)=thisDay;



#k.取出商品在到货时的售价：到《补货系统促销明细》zn_prom_detail中
#找到flag=“2可以补货”的商品并取出促销售价，当前日期+到货周期>促销结束日期时应该取商品的正常售价；
UPDATE tmp_daily_tmp x,zn_prom_detail y 
SET x.trueprice=y.price 
WHERE x.shopid=shopId AND y.shopid=shopId AND x.goodsid=y.goodsid AND  
 y.flag=2 AND DATE_ADD(today,INTERVAL x.arrivaldays+x.safedays-1 DAY)<=y.enddate;


#如果未找到则用zn_goods表中的正常售价normalprice.
UPDATE tmp_daily_tmp x 
SET x.trueprice=x.normalprice 
WHERE ISNULL(x.trueprice);

##！！！促销品补货要根据促销时长采用促销DMS和正常价DMS分段补货

##！！！促销期内非首次促销补货参考最近的促销dms

# m. 取出日均销量：
#--根据促销价格到zn_price_dms取出这些促销品对应的dms, 转n
UPDATE tmp_daily_tmp x,zn_price_dms y 
SET x.dms=y.dms,
x.trueprice=y.trueprice 
WHERE x.shopid=shopId AND y.shopid=shopId AND 
x.goodsid=y.goodsid AND (x.trueprice/x.normalprice)*100>=y.disc1 AND 
(x.trueprice/x.normalprice)*100<y.disc2;

#--当前售价=normalprice，未找到对应的dms或dms=0:说明是新品或者没有正常价销售过，zn_goods表flag=2,转s
UPDATE zn_goods a,tmp_daily_tmp x 
SET a.flag=5,a.trueprice=x.trueprice WHERE a.shopid=shopId AND x.shopid=shopId AND 
a.goodsid=x.goodsid AND (ISNULL(x.dms) OR x.dms=0.0) AND 
x.trueprice=x.normalprice;
delete from tmp_daily_tmp where (ISNULL(dms) OR dms=0.0) and normalprice=trueprice;

#--如果在zn_xl_dms中仍然未找到DMS，zn_goods表flag=2 ,转h
UPDATE zn_goods x,tmp_daily_tmp y 
SET x.flag=4,x.trueprice=y.trueprice WHERE x.shopid=shopId AND y.shopid=shopId AND 
x.goodsid=y.goodsid AND ISNULL(y.dms) ;
delete from tmp_daily_tmp where dms is null;


SELECT "ook3";
SELECT * FROM tmp_daily_tmp;

#n.根据节日属性和季节属性调整日均销量

#--holidaytype=2春节其它商品, 当前日期>=begindate-6进入春节补货模式
#--holidaytype=2春节其它商品, 当前日期>=enddate结束春节补货模式
#春节期间日均销量==b取到的日均销量*zs*rate
UPDATE tmp_daily_tmp x 
SET x.dms=x.dms*x.zs*x.ho_rate 
WHERE x.holidaytype=2 AND x.holiday_begindate<=today AND 
x.holiday_enddate>today;

#--seasontype=1季节性商品 并且 当前日期在period1—period2对应的日期之内时修订日均销量，日均销量=b取到的日均销量*rate1，在period2—enddate对应的日期之内时日均销量=b取到的日均销量*rate2转e
UPDATE tmp_daily_tmp x join zn_season_goods y on x.shopid=y.shopid and x.goodsid=y.goodsid
SET x.dms=CASE WHEN DATE_ADD(concat(year(CURDATE()),'-',y.begindate),INTERVAL 
(DATEDIFF(if(y.begindate<y.enddate,concat(year(CURDATE()),'-',y.enddate),concat(year(curdate())+1,'-',y.enddate)),concat(year(CURDATE()),'-',y.begindate))*x.period1/100) 
DAY)<today and today<if(y.begindate<y.enddate,concat(year(CURDATE()),'-',y.enddate),concat(year(curdate())+1,'-',y.enddate)) THEN x.dms*x.rate1/100.0 
							 WHEN DATE_ADD(concat(year(CURDATE()),'-',y.begindate),INTERVAL 
(DATEDIFF(if(y.begindate<y.enddate,concat(year(CURDATE()),'-',y.enddate),concat(year(curdate())+1,'-',y.enddate)),concat(year(CURDATE()),'-',y.begindate))*x.period2/100) 
DAY)<today and today<if(y.begindate<y.enddate,concat(year(CURDATE()),'-',y.enddate),concat(year(curdate())+1,'-',y.enddate)) THEN x.dms*x.rate2/100.0 
else x.dms END
WHERE x.seasontype=1;


#下面为春节其它商品在春节期间需要调整补货周期、到货周期的规则：
#F2 :一般春节初一至初三不送货（参数控制），因此春节期间最后一个补货日会涉及越期订货问题：到货日期在begindate至enddate之间的最大到货日期对应的补货应该为越期补货
#F3:B、C类商品按照A类商品的规则补货：当前日期>=begindate-6 按照A类订货周期订货
#F4:B、C类商品退出A类商品的规则补货：春节结束后第一个补货日仍然按照A类的补货日进行补货，但是补货周期转成B或C类。
#---T类商品：这个特殊并且量不大，应该按照BC类处理或者按照正常方式补货都行。
#注意补货周期、到货周期的计算：
#（1）今天与下一个补货日之间的天数<4，下一个补货日不再补货，否则补货；
#（2）春节初一至初三可以补货、但是不送货。
#需要补货转g,不需要补货转h
#CALL everyday_procedure_springfestival(shopId,thisDay);

#q．确定补货量：
#理论补货量1=（补货周期+安全库存天数+到货周期）*日均销量 - 当前库存
#理论补货量2=系统设定的最小库存-当前库存
#理论补货量3=max(理论补货量2, 最小订货量)
#理论补货量=max(理论补货量1, 理论补货量3)
#理论补货量<最小订货量时不需要补货，否则需要补货。
#实际补货数量=（（理论补货量/最小起订量）向上取整）*最小起订量。
UPDATE tmp_daily_tmp x 
SET x.actual_qty=CASE WHEN 
((x.arrivaldays+x.safedays+x.weekflag_days)*x.dms-x.closeqty)>(x.minstock-x.closeqty) 
AND ((x.arrivaldays+x.safedays+x.weekflag_days)*x.dms-x.closeqty)>0 
and  ((x.arrivaldays+x.safedays+x.weekflag_days)*x.dms-x.closeqty)>=x.minorder
													THEN CEILING(((x.arrivaldays+x.safedays+x.weekflag_days)*x.dms-x.closeqty)/x.minorder)*x.minorder 
WHEN 
 (x.minstock-x.closeqty)>0 
													THEN CEILING((x.minstock-x.closeqty)/x.minorder)*x.minorder 
ELSE 0 END; 

#s.更新zn_goods表qty、flag、sdate字段;
UPDATE zn_goods x,tmp_daily_tmp y 
SET x.flag=1, 
x.qty=y.actual_qty, 
x.trueprice=y.trueprice, 
x.sdate=today 
 WHERE x.shopid=shopId AND y.shopid=shopId AND 
x.goodsid=y.goodsid and x.flag=0;

#r.更新zn_prom_detail商品状态：zn_goods表中flag=0并且今天是补货日商品但是在《补货系统促销明细》zn_prom_detail中flag=“1越期促销补货”的商品改为flag=‘2可以补货’并更新日期

UPDATE zn_prom_detail x, zn_goods y,zn_config z 
SET x.flag=2, 
		x.sdate=today, 
		y.flag=10 
WHERE x.shopid=shopId AND y.shopid=shopId 
AND x.goodsid=y.goodsid AND 
x.flag=1 AND z.shopid=shopId and z.Classtype=y.classtype and 
SUBSTR(z.orderdate,(dayofweek(thisday)+5)mod 7+1,1)='1' AND 
IF(z.Weekflag=2,z.Startweek mod 2=WEEKOFYEAR(today)mod 2,1) and y.flag!=9;  

END