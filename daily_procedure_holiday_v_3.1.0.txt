BEGIN

DECLARE today date;
DECLARE beginOfthisSeason date;
DECLARE beginOfthisSeasonvachar VARCHAR(255);
DECLARE endOfthisSeason date;
DECLARE endOfthisSeasonvachar VARCHAR(255);
#开始结束日期年份
DECLARE yearOfthisSeasonbegin VARCHAR(255);
DECLARE yearOfthisSeasonend VARCHAR(255);

##促销计划最晚录入时间
declare plan_day int;
##是否有首次补货
declare isholiday int;
select value into isholiday from zn_param where id=6;
select value into plan_day from zn_param where id=4;

SET today=thisDay;
SET yearOfthisSeasonbegin=DATE_FORMAT(today,'%Y');
SET yearOfthisSeasonend=CAST(CAST(yearOfthisSeasonbegin AS SIGNED)+1 AS CHAR(255));
SET beginOfthisSeasonvachar=CASE WHEN 
				ISNULL((SELECT zn_season_goods.begindate FROM zn_season_goods WHERE zn_season_goods.begindate<=DATE_FORMAT(today,'%m-%d') AND 
				zn_season_goods.enddate>DATE_FORMAT(today,'%m-%d') LIMIT 1))=1
		THEN CONCAT(yearOfthisSeasonbegin,'-',(SELECT zn_season_goods.begindate FROM zn_season_goods ORDER BY zn_season_goods.begindate DESC LIMIT 1))
		ELSE CONCAT(yearOfthisSeasonbegin,'-',(SELECT zn_season_goods.begindate FROM zn_season_goods WHERE zn_season_goods.begindate<=DATE_FORMAT(today,'%m-%d') AND 
				zn_season_goods.enddate>DATE_FORMAT(today,'%m-%d') LIMIT 1))
		END;
SET endOfthisSeasonvachar=CASE WHEN 
				ISNULL((SELECT zn_season_goods.begindate FROM zn_season_goods WHERE zn_season_goods.begindate<=DATE_FORMAT(today,'%m-%d') AND 
				zn_season_goods.enddate>=DATE_FORMAT(today,'%m-%d') LIMIT 1))=1
		THEN CONCAT(yearOfthisSeasonend,'-',(SELECT zn_season_goods.begindate FROM zn_season_goods ORDER BY zn_season_goods.begindate ASC LIMIT 1))
		ELSE CONCAT(yearOfthisSeasonbegin,'-',(SELECT zn_season_goods.enddate FROM zn_season_goods WHERE zn_season_goods.begindate<=DATE_FORMAT(today,'%m-%d') AND 
				zn_season_goods.enddate>=DATE_FORMAT(today,'%m-%d') LIMIT 1))
		END;
SET beginOfthisSeason=str_to_date(beginOfthisSeasonvachar,'%Y-%m-%d');
SET endOfthisSeason=str_to_date(endOfthisSeasonvachar,'%Y-%m-%d');


# 首次发现促销品补货

# a0.《补货系统促销明细》中manual_flag=1的商品:补货数量=采购分货数量 
#--如果 采购分货数量=0则  《补货系统促销明细》 flag=0  保持不变并更新日期。
#--如果采购分货数量>0 则 在《补货系统促销明细》中为该商品打标“1越期促销补货” 并更新日期.
#a1.更新zn_goods表qty、flag、sdate字段
if isholiday=1
then
	UPDATE zn_goods a,zn_prom_detail b
	SET a.qty=b.planqty,
	a.flag=6,
	a.sdate=today
	WHERE a.shopid=shopId AND b.shopid=shopId AND
	a.goodsid=b.goodsid AND b.manual_flag=1 AND b.flag=0 and b.planqty>0;

	UPDATE zn_prom_detail a
	SET a.flag=CASE WHEN (a.planqty=0.0) THEN 0 
									WHEN (a.planqty>0.0) THEN 3 end,
			a.sdate=today
	where a.manual_flag=1 and a.flag=0 and a.shopid=shopId;
ELSE
	UPDATE zn_goods a,zn_prom_detail b,zn_config c 
	SET a.qty=b.planqty,
	a.flag=6,
	a.sdate=today
	WHERE a.shopid=shopId AND b.shopid=shopId AND c.shopid=shopId and c.Classtype='A' and SUBSTR(c.Orderdate,(dayofweek(thisday)+5)mod 7+1,1)='1' and
	a.goodsid=b.goodsid AND b.manual_flag=1 AND b.flag=0 and b.planqty>0;

	UPDATE zn_prom_detail a,zn_config b
	SET a.flag=CASE WHEN (a.planqty=0.0) THEN 0 
									WHEN (a.planqty>0.0) THEN 3 end,
			a.sdate=today
	where a.manual_flag=1 and a.flag=0 and a.shopid=shopId and b.shopid=shopId and b.classtype='A' and SUBSTR(b.Orderdate,(dayofweek(thisday)+5)mod 7+1,1)='1';
end if;


#a. 《补货系统促销明细》中manual_flag=0的商品:取出补货类别：到zn_goods中取classtype、minorder、minstock、closeqty等，根据补货类别可以取出补货周期、安全库存天数、到货周期。
DROP TABLE IF EXISTS `tmp_prom_tmp`;
CREATE TABLE IF NOT EXISTS `tmp_prom_tmp` (
  `goodsid` varchar(32) CHARACTER SET utf8mb4 DEFAULT NULL COMMENT '商品编码',
  `shopid` varchar(8) CHARACTER SET utf8mb4 DEFAULT NULL COMMENT '门店编码',
  `normalprice` decimal(16,2) DEFAULT NULL COMMENT '定价',
  `classtype` varchar(1) CHARACTER SET utf8mb4 DEFAULT NULL COMMENT '补货类型',
  `minorder` decimal(16,2) DEFAULT NULL COMMENT '最小起订量',
  `minstock` decimal(16,2) DEFAULT NULL COMMENT '最小库存数量',
  `closeqty` decimal(16,3) DEFAULT NULL COMMENT '昨日日终库存数量',

  `holiday_begindate` datetime DEFAULT NULL COMMENT '节日开始日期',
  `holiday_enddate` datetime DEFAULT NULL COMMENT '节日结束日期',
  `holidaytype` varchar(1) DEFAULT NULL COMMENT '节日属性',
  `zs` decimal(16,2) DEFAULT NULL COMMENT '春节指数',
   xlid varchar(32),
  `ho_rate` decimal(16,2) DEFAULT NULL COMMENT '节日安全系数',

  `seasontype` varchar(1) DEFAULT NULL COMMENT '季节属性',
  `rate1` decimal(16,2) DEFAULT NULL COMMENT '季节时间达到Period1，日均销量的折扣比例',
  `rate2` decimal(16,2) DEFAULT NULL COMMENT '季节时间达到Period2，日均销量的折扣比例',
  `period1` decimal(16,2) DEFAULT NULL COMMENT '季节时间达到的比例1',
  `period2` decimal(16,2) DEFAULT NULL COMMENT '季节时间达到的比例2',

	`startweek`  int(1) NULL DEFAULT 0, 
  `weekflag` char(1) CHARACTER SET utf8 DEFAULT NULL,
  `safedays` int(11) DEFAULT NULL,
  `arrivaldays` int(11) DEFAULT NULL,
  `sdate` datetime DEFAULT NULL COMMENT '更新日期时间',
  `theoritical_qty` decimal(16,2) DEFAULT NULL,
  `actual_qty` decimal(16,2) DEFAULT NULL,
  `price` decimal(16,2) DEFAULT NULL,
  `planqty` decimal(16,3) DEFAULT NULL,
  `flag` char(1) DEFAULT '0',
  `manual_flag` char(1) DEFAULT '0',
  `dms` decimal(16,3) DEFAULT 0 COMMENT '实际售价对应的日均销量',
  `prom_dms` decimal(16,3) DEFAULT 0 COMMENT '实际售价对应的日均销量',
  `leftsalingDays` int(11) DEFAULT NULL COMMENT '当前剩余可销天数',
  `need_replenishment` int(11) DEFAULT NULL COMMENT '需要补货',
  `weekflag_days` int(11) DEFAULT 0 COMMENT 'buhuozhouqi',
   prom_id int(11),
	`display_flag`  varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '0' COMMENT '0—默认值，1—场外  2—堆头  3—端头' ,
	prom_begindate date,
	prom_enddate date,
	prom_days int(11) COMMENT '促销天数',
	prom_alldays int(11) COMMENT 'orderdays+ Arrivaldays+ safedays',
	prom_arriavedate date COMMENT '到货日',
	orderdays int(11) COMMENT 'datediff(下一个补货日,当前日期)',
	now_date date COMMENT '产生补货的日期',
	received_date date COMMENT 'dateadd(now_date,arrivaldays-1)',
	prom_day1 int(11) default 0 COMMENT 'max(min(datediff(enddate, received_date),alldays),0)',
	prom_day2 int(11) COMMENT 'max(（alldays-促销DMS补货天数)，0）',
	prom_flag int(11) COMMENT '促销补货标志位',
  orderdate varchar(10),
  KEY `index_1` (`goodsid`,`shopid`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

TRUNCATE TABLE tmp_prom_tmp;

INSERT INTO tmp_prom_tmp (goodsid,shopid,normalprice,classtype,minorder,minstock,closeqty,
holiday_begindate,holiday_enddate,holidaytype,ho_rate,zs,xlid,seasontype,
rate1,rate2,period1,period2,startweek,weekflag,safedays,arrivaldays,sdate,price,planqty,
flag,manual_flag,weekflag_days,prom_begindate,prom_enddate,prom_id,display_flag,orderdate,prom_day2)
SELECT 
zn_goods.goodsid AS goodsid,
zn_goods.shopid AS shopid,
zn_goods.normalprice AS normalprice,
zn_goods.classtype AS classtype,
zn_goods.minorder AS minorder,
zn_goods.minstock AS minstock,
zn_goods.closeqty AS closeqty,
zn_goods.`holiday_begindate`,
zn_goods.`holiday_enddate`,
zn_goods.`holidaytype`,
zn_goods.`ho_rate`,
zn_goods.`zs`,
zn_goods.`xlid`,
zn_goods.`seasontype`,
zn_goods.`rate1`,
zn_goods.`rate2`,
zn_goods.`period1`,
zn_goods.`period2`,
zn_config.Startweek AS startweek,
zn_config.weekflag AS weekflag,#补货周期
zn_config.safedays AS safedays,#安全库存天数
zn_config.arrivaldays AS arrivaldays,#到货周期
zn_goods.sdate AS sdate,
case when zn_prom_detail.price>zn_goods.normalprice then zn_goods.normalprice else zn_prom_detail.price end AS price,
zn_prom_detail.planqty AS planqty,
zn_prom_detail.flag AS flag,
zn_prom_detail.manual_flag AS manual_flag,
DATEDIFF(get_next_buhuo_date(weekflag,zn_config.Orderdate,zn_config.Startweek,today),today) AS weekflag_days,
zn_prom_detail.begindate as prom_begindate,
zn_prom_detail.enddate as prom_enddate,
zn_prom_detail.id as prom_id,
zn_prom_detail.display_flag as display_flag,
zn_config.Orderdate as orderdate,
DATEDIFF(get_next_buhuo_date(weekflag,zn_config.Orderdate,zn_config.Startweek,today),today)+zn_config.arrivaldays+zn_config.safedays as prom_day2
FROM zn_goods,zn_config,zn_prom_detail
WHERE zn_goods.shopid=shopId AND zn_config.shopid=shopId AND 
zn_prom_detail.shopid=shopId AND zn_goods.goodsid=zn_prom_detail.goodsid AND 
zn_prom_detail.manual_flag=0 AND zn_prom_detail.flag=0 AND zn_goods.flag=0 and
zn_goods.classtype=zn_config.Classtype
 AND datediff(zn_prom_detail.begindate,today)<=plan_day
;


#7-1 首先对新发现的促销品进行优化处理：到《补货系统促销明细》检查该门店是否有新的促销商品，首次发现促销商品（flag=0 and (促销开始日期-当前日期<7)）时首先处理同一个商品存在多条优惠的问题，即多条促销按照最新促销的补货: 根据zn_prom_detail.id判断先后顺序先后。检查促销表里是否还有这个门店这个单品的促销，若有则之前的促销结束日期改为min(新的促销开始日前一天与enddate) ，zn_prom_detail flag=4(被新的促销覆盖)表示以后不会按照这个价格去补货，但是在促销过期后要更新dms.

##多条促销按照最新促销的补货: 根据zn_prom_detail.id判断先后
drop temporary table if exists tmp_prom1;
create temporary table tmp_prom1(
	select shopid,goodsid,max(prom_id) as prom_id
	from tmp_prom_tmp
	group by shopid,goodsid
);
create index index_1 on tmp_prom1(shopid,goodsid);

delete a from tmp_prom_tmp a join tmp_prom1 b on a.shopid=b.shopid and a.goodsid=b.goodsid
where a.prom_id!=b.prom_id;

delete a from zn_prom_detail a join tmp_prom1 b on a.shopid=b.shopid and a.goodsid=b.goodsid 
where a.id!=b.prom_id and a.flag=0;


##查找正在进行的促销数据与首次补货促销数据重复部分
drop table if exists tmp_prom;
create temporary table tmp_prom(
	select b.*
	from zn_prom_detail a join tmp_prom_tmp b on a.shopid=b.shopid and a.goodsid=b.goodsid
	where a.flag in (1,2)
);

##正在进行的促销数据更新结束日期和状态4
update zn_prom_detail a join tmp_prom b on a.shopid=b.shopid and a.goodsid=b.goodsid
set a.enddate=if(a.enddate<date_add(b.prom_begindate,interval -1 day),a.enddate,date_add(b.prom_begindate,interval -1 day)),a.flag=4
where a.begindate<today;
update zn_prom_detail_tmp a join tmp_prom b on a.shopid=b.shopid and a.goodsid=b.goodsid
set a.enddate=if(a.enddate<date_add(b.prom_begindate,interval -1 day),a.enddate,date_add(b.prom_begindate,interval -1 day))
where a.begindate<today;

#7-3、发现促销品则将促销品的补货类型设为A（补货类型为A代表最短的补货周期）：更新zn_goods中促销品的classtype=’A’
##根据参数判断是否需要首次补货
if isholiday=0
THEN
  delete a from tmp_prom_tmp a join zn_config b on a.shopid=b.shopid
  where b.classtype='A' and SUBSTR(b.Orderdate,(dayofweek(thisday)+5)mod 7+1,1)!='1';

	update tmp_prom_tmp a join zn_config b on a.shopid=b.shopid set a.classtype='A',a.startweek=b.startweek,
					a.weekflag=b.weekflag,a.safedays=b.safedays,a.arrivaldays=b.arrivaldays,a.orderdate=b.Orderdate
	where b.classtype='A';

	update tmp_prom_tmp set weekflag_days=DATEDIFF(get_next_buhuo_date(weekflag,Orderdate,Startweek,today),today);

	update zn_goods a join tmp_prom_tmp b on a.shopid=b.shopid and a.goodsid=b.goodsid set a.classtype='A'
	where b.classtype='A';
else 
	##更新越期商品的补货周期天数
	update tmp_prom_tmp a join zn_config b on a.shopid=shopid and b.shopid=shopid and a.classtype=b.Classtype
	set weekflag_days=datediff(get_next_buhuo_date(b.Weekflag,b.Orderdate,b.Startweek,date_add(today,interval weekflag_days+1 day)),today)
	where DATEDIFF(get_next_buhuo_date(b.Weekflag,b.Orderdate,b.Startweek,today),today)<a.arrivaldays;
end if;


UPDATE tmp_prom_tmp x,zn_prom_detail p 
SET x.prom_begindate=p.begindate,
		x.prom_enddate=p.enddate,
		x.prom_days=DATEDIFF(p.enddate,p.begindate)+1,
		x.orderdays=DATEDIFF(get_next_buhuo_date(weekflag,Orderdate,Startweek,today),today),
		x.prom_alldays=DATEDIFF(get_next_buhuo_date(weekflag,Orderdate,Startweek,today),today)+x.arrivaldays+x.safedays,
		x.now_date=thisday,
		x.prom_arriavedate=DATE_ADD(thisday,INTERVAL arrivaldays DAY),
		x.received_date=DATE_ADD(thisday,INTERVAL x.arrivaldays-1 DAY),
		x.prom_day1=0,
		x.prom_day2=DATEDIFF(get_next_buhuo_date(weekflag,Orderdate,Startweek,today),today)+x.arrivaldays+x.safedays,
		x.prom_flag=p.flag
WHERE x.shopid=shopid AND p.shopid=shopid AND x.goodsid=p.goodsid ANd p.flag=0;

#7-7.采购不分货：《补货系统促销明细》中manual_flag=0的商品:取出补货类别：到zn_goods中取classtype、minorder、minstock、closeqty等，根据补货类别可以取出补货周期、安全库存天数、到货周期。
#注意补货周期、到货周期的计算：
#（1）今天与下一个补货日之间的天数<到货周期（这个参数变了，不是4了，意思就是在补货日补货不应该产生越期），下一个补货日不再补货，否则补货；
#（2）春节初一至初三可以补货、但是不送货 
UPDATE tmp_prom_tmp x 
SET x.prom_day1=GREATEST(LEAST(DATEDIFF(x.prom_enddate,x.received_date),x.prom_alldays),0)
WHERE x.shopid=shopid AND (x.prom_days>(x.arrivaldays+x.safedays)) AND NOT ISNULL(x.prom_begindate);

UPDATE tmp_prom_tmp x 
SET x.prom_day2=GREATEST((x.prom_alldays-x.prom_day1),0)
WHERE x.shopid=shopid AND (x.prom_days>=(x.arrivaldays+x.safedays)) AND NOT ISNULL(x.prom_begindate);

			#2、	促销天数<补货周期+到货周期 
UPDATE tmp_prom_tmp x,zn_prom_detail p 
SET x.prom_day1=CASE WHEN ((x.prom_begindate>x.prom_arriavedate)AND(p.flag=0))
													THEN x.prom_days+x.safedays
											ELSE 0 END,
		p.flag=CASE WHEN ((x.prom_begindate>x.prom_arriavedate)AND(p.flag=0))
													THEN 6
											ELSE 0 END
WHERE x.shopid=shopid AND p.shopid=shopid AND x.goodsid=p.goodsid AND (x.prom_days<(x.arrivaldays+x.safedays)) AND NOT ISNULL(x.prom_begindate);

UPDATE tmp_prom_tmp x,zn_prom_detail p 
SET x.prom_day2=x.prom_alldays-x.prom_day1
WHERE x.shopid=shopid AND p.shopid=shopid AND x.goodsid=p.goodsid AND (x.prom_days<(x.arrivaldays+x.safedays)) AND NOT ISNULL(x.prom_begindate);


#7-8. 取出日均销量：
#--促销首次补货（zn_prom_detail.flag=0）时，促销DMS从zn_price_dms中取，
#--促销非首次补货时（zn_prom_detail.flag<>0），首先从zn_prom_detail_tmp表中查找到对应的记录，如果totaldays>=7 则促销dms=totalqty/totaldays,否则到zn_price_dms中取出DMS
#--根据定价到zn_price_dms取出这些商品对应的正常DMS。
#--day2>0 并且未找到normalprice对应的dms或dms=0:说明是新品或者没有正常价销售过，zn_goods表Flag=5 (没有正常定价销售记录),转7-12
#--day1>0 并且未找到当前售价对应的dms或dms=0 : zn_goods表Flag=4 (没有促销销售记录), 转7-12
UPDATE tmp_prom_tmp x,zn_price_dms pd 
SET x.dms=pd.dms
WHERE x.shopid=shopid AND pd.shopid=shopid AND x.goodsid=pd.goodsid and pd.disc1=95;

UPDATE tmp_prom_tmp x,zn_price_dms pd 
SET x.prom_dms=pd.dms
WHERE x.shopid=shopid AND pd.shopid=shopid AND x.goodsid=pd.goodsid and (x.price/x.normalprice)*100>=pd.disc1 AND 
(x.price/x.normalprice)*100<pd.disc2 and x.display_flag=pd.display_flag;

UPDATE zn_goods z,tmp_prom_tmp x 
SET z.flag=5,z.trueprice=x.price
WHERE z.shopid=shopid AND x.shopid=shopid AND z.goodsid=x.goodsid AND (ISNULL(x.dms)OR x.dms=0.0) AND x.prom_day2>0;
UPDATE zn_prom_detail z,tmp_prom_tmp x 
SET z.flag=2
WHERE z.shopid=shopid AND x.shopid=shopid AND z.goodsid=x.goodsid AND (ISNULL(x.dms)OR x.dms=0.0) AND x.prom_day2>0 and x.flag=0;
delete from tmp_prom_tmp where (ISNULL(dms)OR(dms=0.0)) AND prom_day2>0;

UPDATE zn_goods x,tmp_prom_tmp y
SET x.flag=4,x.trueprice=y.price WHERE x.shopid=shopid and y.shopid=shopid and x.goodsid=y.goodsid and (ISNULL(y.prom_dms)OR(y.prom_dms=0.0)or(y.prom_dms=-0.1)) ;
UPDATE zn_prom_detail x,tmp_prom_tmp y
SET x.flag=2 WHERE x.shopid=shopid and y.shopid=shopid and x.goodsid=y.goodsid and (ISNULL(y.prom_dms)OR(y.prom_dms=0.0)or(y.prom_dms=-0.1)) and x.flag=0 ;
delete from tmp_prom_tmp where (ISNULL(prom_dms)OR(prom_dms=0.0)or(prom_dms=-1.0)) and prom_day1>0;


#7-9根据节日属性和季节属性调整日均销量
#--holidaytype=2春节其它商品, 当前日期>=begindate-6进入春节补货模式 
#--holidaytype=2春节其它商品, 当前日期>=enddate结束春节补货模式
#春节期间日均销量==m取到的2个日均销量*zs*rate  转o
#--seasontype=1季节性商品 并且 当前日期在period1—period2对应的日期之内时修订日均销量，日均销量=m取到的2个日均销量*rate1，在period2—enddate对应的日期之内时日均销量=m取到的2个日均销量*rate2转7-10
UPDATE tmp_prom_tmp x 
SET x.dms=x.dms*x.zs*x.ho_rate, 
		x.prom_dms=x.prom_dms*x.zs*x.ho_rate 
WHERE x.holidaytype=2 AND x.holiday_begindate<=today AND 
x.holiday_enddate>=today;

UPDATE tmp_prom_tmp x join zn_season_goods y on x.shopid=y.shopid and x.goodsid=y.goodsid
SET x.dms=CASE WHEN DATE_ADD(concat(year(CURDATE()),'-',y.begindate),INTERVAL 
(DATEDIFF(if(y.begindate<y.enddate,concat(year(CURDATE()),'-',y.enddate),concat(year(curdate())+1,'-',y.enddate)),concat(year(CURDATE()),'-',y.begindate))*x.period1/100) 
DAY)<today and today<if(y.begindate<y.enddate,concat(year(CURDATE()),'-',y.enddate),concat(year(curdate())+1,'-',y.enddate)) THEN x.dms*x.rate1/100.0 
							 WHEN DATE_ADD(concat(year(CURDATE()),'-',y.begindate),INTERVAL 
(DATEDIFF(if(y.begindate<y.enddate,concat(year(CURDATE()),'-',y.enddate),concat(year(curdate())+1,'-',y.enddate)),concat(year(CURDATE()),'-',y.begindate))*x.period2/100) 
DAY)<today and today<if(y.begindate<y.enddate,concat(year(CURDATE()),'-',y.enddate),concat(year(curdate())+1,'-',y.enddate)) THEN x.dms*x.rate2/100.0 
else x.dms END,
x.prom_dms=CASE WHEN DATE_ADD(concat(year(CURDATE()),'-',y.begindate),INTERVAL 
(DATEDIFF(if(y.begindate<y.enddate,concat(year(CURDATE()),'-',y.enddate),concat(year(curdate())+1,'-',y.enddate)),concat(year(CURDATE()),'-',y.begindate))*x.period1/100) 
DAY)<today and today<if(y.begindate<y.enddate,concat(year(CURDATE()),'-',y.enddate),concat(year(curdate())+1,'-',y.enddate)) THEN x.prom_dms*x.rate1/100.0 
							 WHEN DATE_ADD(concat(year(CURDATE()),'-',y.begindate),INTERVAL 
(DATEDIFF(if(y.begindate<y.enddate,concat(year(CURDATE()),'-',y.enddate),concat(year(curdate())+1,'-',y.enddate)),concat(year(CURDATE()),'-',y.begindate))*x.period2/100) 
DAY)<today and today<if(y.begindate<y.enddate,concat(year(CURDATE()),'-',y.enddate),concat(year(curdate())+1,'-',y.enddate)) THEN x.prom_dms*x.rate2/100.0 
else x.prom_dms END
WHERE x.seasontype=1;


#7-10．确定补货量：
#理论补货量1=促销DMS补货天数day1*促销dms+非促销补货天数day2*非促销dms  - 当前库存
#理论补货量2=系统设定的最小库存-当前库存
#If  理论补货量2<0  and理论补货量1 < 最小订货量 then不需要补货
#Else  需要补货。
#理论补货量3=max(理论补货量2, 最小订货量)
#理论补货量 =max(理论补货量1, 理论补货量3)
#实际补货数量=（（理论补货量/最小订货量）向上取整）*最小订货量。
#end
UPDATE tmp_prom_tmp x 
SET x.actual_qty=CASE WHEN ((x.prom_day1*x.prom_dms+x.prom_day2*x.dms-x.closeqty<x.minorder) AND (x.minstock<=x.closeqty))
														THEN 0.0
														ELSE CEILING(GREATEST(x.prom_day1*x.prom_dms+x.prom_day2*x.dms-x.closeqty,x.minstock-x.closeqty,x.minorder)/x.minorder)*x.minorder END; 


#7-11更新zn_goods表qty、flag=9（促销首次补货）
UPDATE zn_goods x,tmp_prom_tmp y
SET x.flag=9,
x.qty=y.actual_qty,
x.trueprice=y.price,
x.sdate=now()
 WHERE x.shopid=shopId AND y.shopid=shopId AND
x.goodsid=y.goodsid;


#7-12更新zn_goods表sdate字段;在《补货系统促销明细》中为该商品打标“1越期促销补货”或“2可以补货”并更新日期sdate字段
UPDATE zn_prom_detail a,tmp_prom_tmp y
SET a.flag=2,
		a.sdate=now()
WHERE a.shopid=shopId AND y.shopid=shopId AND a.begindate=y.prom_begindate and a.enddate=y.prom_enddate and
a.goodsid=y.goodsid;


if isholiday=1
then
	UPDATE zn_prom_detail a,tmp_prom_tmp y,zn_config z
	SET a.flag=1,
			a.sdate=now()
	WHERE a.shopid=shopId AND y.shopid=shopId AND a.begindate=y.prom_begindate and a.enddate=y.prom_enddate and
	a.goodsid=y.goodsid and z.shopid=shopId and y.classtype=z.Classtype and DATEDIFF(get_next_buhuo_date(z.weekflag,z.Orderdate,z.Startweek,today),today)<y.arrivaldays
	;
end if;

END