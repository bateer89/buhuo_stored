BEGIN

DECLARE today date;
DECLARE beginOfthisSeason date;
DECLARE beginOfthisSeasonvachar VARCHAR(255);
DECLARE endOfthisSeason date;
DECLARE endOfthisSeasonvachar VARCHAR(255);
#开始结束日期年份
DECLARE yearOfthisSeasonbegin VARCHAR(255);
DECLARE yearOfthisSeasonend VARCHAR(255);
##短期促销时长
declare abct_day int;
##促销计划最晚录入时间
declare plan_day int;

declare isholiday int;
select value into isholiday from zn_param where id=6;

select value into plan_day from zn_param where id=4;
select value into abct_day from zn_param where id=5;

SET today=thisDay;
SET yearOfthisSeasonbegin=DATE_FORMAT(today,'%Y');
SET yearOfthisSeasonend=CAST(CAST(yearOfthisSeasonbegin AS SIGNED)+1 AS CHAR(255));
SET beginOfthisSeasonvachar=CASE WHEN 
				ISNULL((SELECT zn_season_goods.begindate FROM zn_season_goods WHERE zn_season_goods.begindate<=DATE_FORMAT(today,'%m-%d') AND 
				zn_season_goods.enddate>DATE_FORMAT(today,'%m-%d') LIMIT 1))=1
		THEN CONCAT(yearOfthisSeasonbegin,'-',(SELECT zn_season_goods.begindate FROM zn_season_goods ORDER BY zn_season_goods.begindate DESC LIMIT 1))
		ELSE CONCAT(yearOfthisSeasonbegin,'-',(SELECT zn_season_goods.begindate FROM zn_season_goods WHERE zn_season_goods.begindate<=DATE_FORMAT(today,'%m-%d') AND 
				zn_season_goods.enddate>DATE_FORMAT(today,'%m-%d') LIMIT 1))
		END;
SET endOfthisSeasonvachar=CASE WHEN 
				ISNULL((SELECT zn_season_goods.begindate FROM zn_season_goods WHERE zn_season_goods.begindate<=DATE_FORMAT(today,'%m-%d') AND 
				zn_season_goods.enddate>=DATE_FORMAT(today,'%m-%d') LIMIT 1))=1
		THEN CONCAT(yearOfthisSeasonend,'-',(SELECT zn_season_goods.begindate FROM zn_season_goods ORDER BY zn_season_goods.begindate ASC LIMIT 1))
		ELSE CONCAT(yearOfthisSeasonbegin,'-',(SELECT zn_season_goods.enddate FROM zn_season_goods WHERE zn_season_goods.begindate<=DATE_FORMAT(today,'%m-%d') AND 
				zn_season_goods.enddate>=DATE_FORMAT(today,'%m-%d') LIMIT 1))
		END;
SET beginOfthisSeason=str_to_date(beginOfthisSeasonvachar,'%Y-%m-%d');
SET endOfthisSeason=str_to_date(endOfthisSeasonvachar,'%Y-%m-%d');


# 首次发现促销品补货
#开始促销商品补货：到《补货系统促销明细》检查该门店是否有新的促销商品，首次发现促销商品（flag=0）马上触发促销商品的补货：

# a0.《补货系统促销明细》中manual_flag=1的商品:补货数量=采购分货数量 
#--如果 采购分货数量=0则  《补货系统促销明细》 flag=0  保持不变并更新日期。
#--如果采购分货数量>0 则 在《补货系统促销明细》中为该商品打标“1越期促销补货” 并更新日期.
#a1.更新zn_goods表qty、flag、sdate字段
if isholiday=1
then
	UPDATE zn_goods a,zn_prom_detail b
	SET a.qty=b.planqty,
	a.flag=6,
	a.sdate=today
	WHERE a.shopid=shopId AND b.shopid=shopId AND
	a.goodsid=b.goodsid AND b.manual_flag=1 AND b.flag=0 and b.planqty>0;

	UPDATE zn_prom_detail a
	SET a.flag=CASE WHEN (a.planqty=0.0) THEN 0 
									WHEN (a.planqty>0.0) THEN 3 end,
			a.sdate=today
	where a.manual_flag=1 and a.flag=0 and a.shopid=shopId;
ELSE
	UPDATE zn_goods a,zn_prom_detail b,zn_config c 
	SET a.qty=b.planqty,
	a.flag=6,
	a.sdate=today
	WHERE a.shopid=shopId AND b.shopid=shopId AND c.shopid=shopId and c.Classtype='A' and SUBSTR(c.Orderdate,(dayofweek(thisday)+5)mod 7+1,1)='1' and
	a.goodsid=b.goodsid AND b.manual_flag=1 AND b.flag=0 and b.planqty>0;

	UPDATE zn_prom_detail a,zn_config b
	SET a.flag=CASE WHEN (a.planqty=0.0) THEN 0 
									WHEN (a.planqty>0.0) THEN 3 end,
			a.sdate=today
	where a.manual_flag=1 and a.flag=0 and a.shopid=shopId and b.shopid=shopId and b.classtype='A' and SUBSTR(b.Orderdate,(dayofweek(thisday)+5)mod 7+1,1)='1';
end if;


#a. 《补货系统促销明细》中manual_flag=0的商品:取出补货类别：到zn_goods中取classtype、minorder、minstock、closeqty等，根据补货类别可以取出补货周期、安全库存天数、到货周期。
CREATE TABLE IF NOT EXISTS `tmp_prom_tmp` (
  `goodsid` varchar(32) CHARACTER SET utf8mb4 DEFAULT NULL COMMENT '商品编码',
  `shopid` varchar(8) CHARACTER SET utf8mb4 DEFAULT NULL COMMENT '门店编码',
  `normalprice` decimal(16,2) DEFAULT NULL COMMENT '定价',
  `classtype` varchar(1) CHARACTER SET utf8mb4 DEFAULT NULL COMMENT '补货类型',
  `minorder` decimal(16,2) DEFAULT NULL COMMENT '最小起订量',
  `minstock` decimal(16,2) DEFAULT NULL COMMENT '最小库存数量',
  `closeqty` decimal(16,3) DEFAULT NULL COMMENT '昨日日终库存数量',

  `holiday_begindate` datetime DEFAULT NULL COMMENT '节日开始日期',
  `holiday_enddate` datetime DEFAULT NULL COMMENT '节日结束日期',
  `holidaytype` varchar(1) DEFAULT NULL COMMENT '节日属性',
  `zs` decimal(16,2) DEFAULT NULL COMMENT '春节指数',
   xlid varchar(32),
  `ho_rate` decimal(16,2) DEFAULT NULL COMMENT '节日安全系数',

  `seasontype` varchar(1) DEFAULT NULL COMMENT '季节属性',
  `rate1` decimal(16,2) DEFAULT NULL COMMENT '季节时间达到Period1，日均销量的折扣比例',
  `rate2` decimal(16,2) DEFAULT NULL COMMENT '季节时间达到Period2，日均销量的折扣比例',
  `period1` decimal(16,2) DEFAULT NULL COMMENT '季节时间达到的比例1',
  `period2` decimal(16,2) DEFAULT NULL COMMENT '季节时间达到的比例2',

	`startweek`  int(1) NULL DEFAULT 0, 
  `weekflag` char(1) CHARACTER SET utf8 DEFAULT NULL,
  `safedays` int(11) DEFAULT NULL,
  `arrivaldays` int(11) DEFAULT NULL,
  `sdate` datetime DEFAULT NULL COMMENT '更新日期时间',
  `theoritical_qty` decimal(16,2) DEFAULT NULL,
  `actual_qty` decimal(16,2) DEFAULT NULL,
  `price` decimal(16,2) DEFAULT NULL,
  `planqty` decimal(16,3) DEFAULT NULL,
  `flag` char(1) DEFAULT '0',
  `manual_flag` char(1) DEFAULT '0',
  `dms` decimal(16,3) DEFAULT NULL COMMENT '实际售价对应的日均销量',
  `leftsalingDays` int(11) DEFAULT NULL COMMENT '当前剩余可销天数',
  `need_replenishment` int(11) DEFAULT NULL COMMENT '需要补货',
  `weekflag_days` int(11) DEFAULT 0 COMMENT 'buhuozhouqi',
  KEY `index_1` (`goodsid`,`shopid`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

TRUNCATE TABLE tmp_prom_tmp;

INSERT INTO tmp_prom_tmp (goodsid,shopid,normalprice,classtype,minorder,minstock,closeqty,
holiday_begindate,holiday_enddate,holidaytype,ho_rate,zs,xlid,seasontype,
rate1,rate2,period1,period2,startweek,weekflag,safedays,arrivaldays,sdate,price,planqty,
flag,manual_flag,weekflag_days,begindate,enddate,prom_id)
SELECT 
zn_goods.goodsid AS goodsid,
zn_goods.shopid AS shopid,
zn_goods.normalprice AS normalprice,
zn_goods.classtype AS classtype,
zn_goods.minorder AS minorder,
zn_goods.minstock AS minstock,
zn_goods.closeqty AS closeqty,
zn_goods.`holiday_begindate`,
zn_goods.`holiday_enddate`,
zn_goods.`holidaytype`,
zn_goods.`ho_rate`,
zn_goods.`zs`,
zn_goods.`xlid`,
zn_goods.`seasontype`,
zn_goods.`rate1`,
zn_goods.`rate2`,
zn_goods.`period1`,
zn_goods.`period2`,
zn_config.Startweek AS startweek,
zn_config.weekflag AS weekflag,#补货周期
zn_config.safedays AS safedays,#安全库存天数
zn_config.arrivaldays AS arrivaldays,#到货周期
zn_goods.sdate AS sdate,
zn_prom_detail.price AS price,
zn_prom_detail.planqty AS planqty,
zn_prom_detail.flag AS flag,
zn_prom_detail.manual_flag AS manual_flag,
DATEDIFF(get_next_buhuo_date(weekflag,zn_config.Orderdate,zn_config.Startweek,today),today) AS weekflag_days,
zn_prom_detail.begindate as begindate,
zn_prom_detail.enddate as enddate,
zn_prom_detail.id as prom_id
FROM zn_goods,zn_config,zn_prom_detail
WHERE zn_goods.shopid=shopId AND zn_config.shopid=shopId AND 
zn_prom_detail.shopid=shopId AND zn_goods.goodsid=zn_prom_detail.goodsid AND 
zn_prom_detail.manual_flag=0 AND zn_prom_detail.flag=0 AND zn_goods.flag=0 and
zn_goods.classtype=zn_config.Classtype
 AND datediff(zn_prom_detail.begindate,today)<=plan_day and datediff(zn_prom_detail.begindate,today)>0
;

##多条促销按照最新促销的补货: 根据zn_prom_detail.id判断先后
drop temporary table if exists tmp_prom1;
create temporary table tmp_prom1(
	select shopid,goodsid,max(prom_id) as prom_id
	from tmp_prom_tmp
	group by shopid,goodsid
);
create index index_1 on tmp_prom1(shopid,goodsid);

delete a from tmp_prom_tmp a join tmp_prom1 b on a.shopid=b.shopid and a.goodsid=b.goodsid
where a.prom_id!=b.prom_id;

delete a from zn_prom_detail a join tmp_prom1 b on a.shopid=b.shopid and a.goodsid=b.goodsid 
where a.id!=b.prom_id;


##查找正在进行的促销数据与首次补货促销数据重复部分
drop table if exists tmp_prom;
create temporary table tmp_prom(
	select b.*
	from zn_prom_detail a join tmp_prom_tmp b on a.shopid=b.shopid and a.goodsid=b.goodsid
	where a.flag in (1,2)
);

##正在进行的促销数据更新结束日期和状态4
update zn_prom_detail a join tmp_prom b on a.shopid=b.shopid and a.goodsid=b.goodsid
set a.enddate=if(a.enddate<date_add(b.begindate,interval -1 day),a.enddate,date_add(b.begindate,interval -1 day)),a.flag=4
where a.begindate<today;
update zn_prom_detail_tmp a join tmp_prom b on a.shopid=b.shopid and a.goodsid=b.goodsid
set a.enddate=if(a.enddate<date_add(b.begindate,interval -1 day),a.enddate,date_add(b.begindate,interval -1 day))
where a.begindate<today;

##根据参数判断是否需要首次补货
if isholiday=0
THEN
  delete a from tmp_prom_tmp a join zn_config b on a.shopid=b.shopid
  where b.classtype='A' and SUBSTR(b.Orderdate,(dayofweek(thisday)+5)mod 7+1,1)!='1';

	update tmp_prom_tmp a join zn_config b on a.shopid=b.shopid set a.classtype='A',a.Startweek=b.startweek,
					a.weekflag=b.weekflag,a.safedays=b.safedays,a.arrivaldays=b.arrivaldays
	where b.classtype='A';
else 
	##更新越期商品的补货周期天数
	update tmp_prom_tmp a join zn_config b on a.shopid=shopid and b.shopid=shopid and a.classtype=b.Classtype
	set weekflag_days=datediff(get_next_buhuo_date(b.Weekflag,b.Orderdate,b.Startweek,date_add(today,interval weekflag_days+1 day)),today)
	where DATEDIFF(get_next_buhuo_date(b.Weekflag,b.Orderdate,b.Startweek,today),today)<a.arrivaldays;
end if;


##！！！
##分段计算补货天数：促销品补货要根据促销时长采用促销DMS和正常价DMS分段补货，彻底解决短期促销无法补货和促销临近结束时补货量偏大的问题


# b. 取出日均销量：
#--根据促销价格到zn_price_dms取出这些促销品对应的dms, 转c
UPDATE tmp_prom_tmp x,zn_price_dms y
SET x.dms=y.dms
WHERE x.shopid=shopId AND y.shopid=shopId AND
x.goodsid=y.goodsid AND (x.price/x.normalprice)*100>=y.disc1 AND 
(x.price/x.normalprice)*100<y.disc2;


#--如果在zn_xl_dms中仍然未找到DMS，zn_goods表flag=2 ,转h
UPDATE zn_goods x,tmp_prom_tmp y
SET x.flag=4,x.trueprice=y.price WHERE x.shopid=shopid and y.shopid=shopid and x.goodsid=y.goodsid and ISNULL(y.dms) ;
UPDATE zn_prom_detail a,tmp_prom_tmp y 
SET a.flag=2,
		a.sdate=today 
WHERE a.shopid=shopId AND y.shopid=shopId AND a.goodsid=y.goodsid and ISNULL(y.dms);
delete from tmp_prom_tmp where dms is null;


##  Todo:更新首次补货记录?

#c.根据节日属性和季节属性调整日均销量

#--holidaytype=2春节其它商品, 当前日期>=begindate-6进入春节补货模式
#--holidaytype=2春节其它商品, 当前日期>=enddate结束春节补货模式
#春节期间日均销量==b取到的日均销量*zs*rate
UPDATE tmp_prom_tmp x 
SET x.dms=x.dms*x.zs*x.ho_rate 
WHERE x.holidaytype=2 AND date_add(x.holiday_begindate,interval -6 day)<=today AND 
x.holiday_enddate>today;

#--seasontype=1季节性商品 并且 当前日期在period1—period2对应的日期之内时修订日均销量，日均销量=b取到的日均销量*rate1，
#在period2—enddate对应的日期之内时日均销量=b取到的日均销量*rate2转e
UPDATE tmp_prom_tmp x join zn_season_goods y on x.shopid=y.shopid and x.goodsid=y.goodsid
SET x.dms=CASE WHEN DATE_ADD(concat(year(CURDATE()),'-',y.begindate),INTERVAL 
(DATEDIFF(if(y.begindate<y.enddate,concat(year(CURDATE()),'-',y.enddate),concat(year(curdate())+1,'-',y.enddate)),concat(year(CURDATE()),'-',y.begindate))*x.period1/100) 
DAY)<today and today<if(y.begindate<y.enddate,concat(year(CURDATE()),'-',y.enddate),concat(year(curdate())+1,'-',y.enddate)) THEN x.dms*x.rate1/100.0 
							 WHEN DATE_ADD(concat(year(CURDATE()),'-',y.begindate),INTERVAL 
(DATEDIFF(if(y.begindate<y.enddate,concat(year(CURDATE()),'-',y.enddate),concat(year(curdate())+1,'-',y.enddate)),concat(year(CURDATE()),'-',y.begindate))*x.period2/100) 
DAY)<today and today<if(y.begindate<y.enddate,concat(year(CURDATE()),'-',y.enddate),concat(year(curdate())+1,'-',y.enddate)) THEN x.dms*x.rate2/100.0 
else x.dms END
WHERE x.seasontype=1;


#下面为春节其它商品在春节期间需要调整补货周期、到货周期的规则：
#F2 :一般春节初一至初三不送货（参数控制），因此春节期间最后一个补货日会涉及越期订货问题：到货日期在begindate至enddate之间的最大到货日期对应的补货应该为越期补货
#F3:B、C类商品按照A类商品的规则补货：当前日期>=begindate-6 按照A类订货周期订货
#F4:B、C类商品退出A类商品的规则补货：春节结束后第一个补货日仍然按照A类的补货日进行补货，但是补货周期转成B或C类。
#---T类商品：这个特殊并且量不大，应该按照BC类处理或者按照正常方式补货都行。
#注意补货周期、到货周期的计算：
#（1）今天与下一个补货日之间的天数<4，下一个补货日不再补货，否则补货；
#（2）春节初一至初三可以补货、但是不送货。
#需要补货转g,不需要补货转h
##CALL everyday_procedure_springfestival(shopId,thisDay);

#g．确定补货量：
#理论补货量1=（补货周期+安全库存天数+到货周期）*日均销量 - 当前库存
#理论补货量2=系统设定的最小库存-当前库存
#理论补货量3=max(理论补货量2, 最小订货量)
#理论补货量=max(理论补货量1, 理论补货量3)
#理论补货量<最小订货量时不需要补货，否则需要补货。
#实际补货数量=（（理论补货量/最小起订量）向上取整）*最小起订量。
UPDATE tmp_prom_tmp x 
SET x.actual_qty=CASE WHEN 
((x.arrivaldays+x.safedays+x.weekflag_days)*x.dms-x.closeqty)>=(x.minstock-x.closeqty)
AND ((x.arrivaldays+x.safedays+x.weekflag_days)*x.dms-x.closeqty)>0
and  ((x.arrivaldays+x.safedays+x.weekflag_days)*x.dms-x.closeqty)>=x.minorder
													THEN CEILING(((x.arrivaldays+x.safedays+x.weekflag_days)*x.dms-x.closeqty)/x.minorder)*x.minorder
											WHEN
(x.minstock-x.closeqty)>0
													THEN CEILING((x.minstock-x.closeqty)/x.minorder)*x.minorder
ELSE 0 END;


#h.更新zn_goods表qty、flag、sdate字段;
#h.更新zn_goods表qty、flag、sdate字段;
UPDATE zn_goods x,tmp_prom_tmp y
SET x.flag=9,
x.qty=y.actual_qty,
x.trueprice=y.price,
x.sdate=today
 WHERE x.shopid=shopId AND y.shopid=shopId AND
x.goodsid=y.goodsid;

#在《补货系统促销明细》中为该商品打标“1越期促销补货”或“2可以补货”并更新日期.
UPDATE zn_prom_detail a,tmp_prom_tmp y
SET a.flag=2,
		a.sdate=today
WHERE a.shopid=shopId AND y.shopid=shopId AND a.begindate=y.begindate and a.enddate=y.enddate and
a.goodsid=y.goodsid;

if isholiday=1
then
	UPDATE zn_prom_detail a,tmp_prom_tmp y,zn_config z
	SET a.flag=1,
			a.sdate=today
	WHERE a.shopid=shopId AND y.shopid=shopId AND a.begindate=y.begindate and a.enddate=y.enddate and
	a.goodsid=y.goodsid and z.shopid=shopId and y.classtype=z.Classtype and DATEDIFF(get_next_buhuo_date(z.weekflag,z.Orderdate,z.Startweek,today),today)<y.arrivaldays
	;
end if;

END